`timescale 1ns / 1ps
////////////////////////////////////////////////////////////////////////////////// 
// Engineer: Jacob Bograd
// 
// Create Date: 11/17/2020 12:21:19 PM
// Design Name: FSM for memory check
// Module Name: FSM_Case_0
// Description: This is the FSM for checking if the user input is the same as the nuber displayed on the screen
// This is going to be copy and patesd for all 15 cases, the FSM is going to be powerd on if it's nubmer is generated by the random number generator
// 
//
//
//              THIS TEST CASE IS FOR: 251F : 0010 0101 0001 1111
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////


module CounterFSM(
   // input [15:0]switches,
    //input power,
    input clk,
   // input check, //check might not be needed going to start off of power first, if it does not stop then will have check be the starter
   // output logic cc,
    output logic [3:0] randNum
    );
    parameter [4:0] START = 5'b00000; //this is the starting state, if a FSM check fails it gets passed back to this
    logic [4:0] NS; // this is the next states
    logic [4:0] PS = a; //this is defianing the first rotation MIGHT BREAK SOMETHING
    //all of the states represent one of the bits in switches
    logic [4:0] a = 5'b00000;// state 1   //bit 0
    logic [4:0] b = 5'b00001;// state 2   //bit 1
    logic [4:0] c = 5'b00010;// state 3   //bit 2
    logic [4:0] d = 5'b00011;// state 4   //bit 3
    logic [4:0] e = 5'b00100;// state 5   //bit 4
    logic [4:0] f = 5'b00101;// state 6   //bit 5
    logic [4:0] g = 5'b00110;// state 7   //bit 6
    logic [4:0] h = 5'b00111;// state 8   //bit 7
    logic [4:0] i = 5'b01000;// state 9   //bit 8
    logic [4:0] j = 5'b01001;// state 10  //bit 9
    logic [4:0] k = 5'b01010;// state 11  //bit 10
    logic [4:0] L = 5'b01011;// state 12  //bit 11
    logic [4:0] m = 5'b01100;// state 13  //bit 12
    logic [4:0] n = 5'b01101;// state 14  //bit 13
    logic [4:0] o = 5'b01110;// state 15  //bit 14
    logic [4:0] p = 5'b01111;// state 16  //bit 15  
    logic [4:0] FAIL = 5'b11111; //this is what the state goes to if the test case fails
    logic [4:0] DONE = 5'b10111; //This is the ending state which just holds
    
    always_ff @(posedge clk)//lets just make this depending on the clock, posedge check)// now just making it based on clock, posedge check) //this checks every clock as well on the posedge of check, it just keeps resetting
    begin
    PS = NS;
//    if(check == 1)
//    begin
//        PS = START;
//    end
//    else
//    begin
//        PS = NS;
//    end
    end
    

    
    
    
    always_comb
    begin
 //start off with crap

  //  if(power == 1)//this is checking if this FSM is powerd on //temp removing power is somewhere else
  //  begin
    case(PS)
        a:// this is checking if the first bit is correct
        begin
        randNum = 4'b0000;
                    NS = b;
       end
        b:// this is checking if the second bit is correc
            begin
        randNum = 4'b0001;
                    NS = c;
            end
       
        c:// this is checking if the thrid bit is correct
        begin
        randNum = 4'b0010;
                    NS = d;
       
       end
        d:// this is checking if the forth bit is correct
        begin
        randNum = 4'b0011;
                    NS = e;
       
       end
        e:// this is checking if the fifth bit is correct
        begin
        randNum = 4'b0100;
                    NS = f;
       
       end
        f:// this is checking if the sixth bit is correct
        
        begin
        randNum = 4'b0101;
                    NS = g;
       end
        g:// this is checking if the seventh bit is correct
        begin
        randNum = 4'b0110;
                    NS = h;
       end
        h:// this is checking if the eight bit is correct
        begin
        randNum = 4'b0111;
                    NS = i;
       end
        i:// this is checking if the ninth bit is correct
        begin
        randNum = 4'b1000;
                    NS = j;
       
       end
        j:// this is checking if the tenth bit is correct
        begin
        randNum = 4'b1001;
                    NS = k;
       end
        k:// this is checking if the 11 bit is correct
        begin
        randNum = 4'b1010;
                    NS = L;
       end
        L:// this is checking if the 12 bit is correct
        begin
        randNum = 4'b1011;
                    NS = m;
       
       end
        m:// this is checking if the 13 bit is correct
        begin
        randNum = 4'b1100;
                    NS = n;
       end      
       n:// this is checking if the 14  bit is correct
        begin
        randNum = 4'b1101;
                    NS = o;
       end      
         o:// this is checking if the 15 bit is correct
        begin
        randNum = 4'b1110;
                    NS = p;
       
       end
        p:// this is checking if the 16 bit is correct
        begin
        randNum = 4'b1111;
                    NS = a;
       
       end
       default: //this is the defualt case to catch anything that slipped through the cracks
        begin
        randNum = 4'b1010;
        NS = a;
        end
        endcase
//    end
end
endmodule
